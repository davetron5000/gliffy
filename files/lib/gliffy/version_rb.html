<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>version.rb</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../../../css/main.css" type="text/css" media="screen" />
    <script src="../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            version.rb
        </h1>
        <ul class="files">
            <li>lib/gliffy/version.rb</li>
            <li>Last modified: Mon Feb 01 18:31:47 -0500 2010</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
Generated by rake update_version
</p>
<hr size="1"></hr><p>
This is the Ruby client library for interacting with <a
href="http://www.gliffy.com">Gliffy</a>. It&#8217;s main function is for
you to integrate <a href="../../../classes/Gliffy.html">Gliffy</a>
documents into the workflow of another application.
</p>
<h1>Getting Started</h1>
<pre>
    sudo gem install gliffy
</pre>
<ul>
<li>Source - <a
href="http://github.com/davetron5000/gliffy/tree/master">github.com/davetron5000/gliffy/tree/master</a>

</li>
<li>RDoc - <a
href="http://davetron5000.github.com/gliffy">davetron5000.github.com/gliffy</a>

</li>
</ul>
<h1>Overview</h1>
<p>
The main entry point to <a href="../../../classes/Gliffy.html">Gliffy</a>
is <a href="../../../classes/Gliffy/Handle.html">Gliffy::Handle</a>, which
provides high-level access to most features available from the API. You
should instantiate one of these objects per <em>user session</em>. To
create it, you will need to create and populate an instance of the
Credentials class. This class is constructed almost entirely from static
data about your <a href="../../../classes/Gliffy.html">Gliffy</a> account,
so you will probably configure an instance of this globally.
</p>
<p>
This is then used (along with the API root to <a
href="../../../classes/Gliffy.html">Gliffy</a>) to create an instance of <a
href="../../../classes/Gliffy/Handle.html">Gliffy::Handle</a>. Objects of
this class provide access to the features you will need to integrate <a
href="../../../classes/Gliffy.html">Gliffy</a> into your app&#8217;s
workflow.
</p>
<h2>Example</h2>
<p>
Suppose you have created a group blog application using Rails and wish to
give Blog authors the ability to use <a
href="../../../classes/Gliffy.html">Gliffy</a> diagrams. In
<tt>config/initializers/gliffy.rb</tt> you might configure values for the
Credential object
</p>
<pre>
    $gliffy_api_key = 'your-consumer-key-here'
    $gliffy_secret = 'your-secret-here'
    $gliffy_app_description = 'My Awesome Group Blog',
    $gliffy_account_id = 655321
    $gliffy_root = 'www.gliffy.com/api/1.0'
    $gliffy_edit_root = 'www.gliffy.com/gliffy'
</pre>
<p>
Then, in your <tt>sessions_controller.rb</tt>:
</p>
<pre>
    require 'gliffy'

    def create
      self.current_user = User.authenticate(params[:email],params[:password])
      if logged_in?
        # Whatever you do when they log in successfully
        # Then create the credentials object
        cred = Credentials.new(\
          $gliffy_api_key,
          $gliffy_secret,
          $gliffy_app_description,
          $gliffy_account_id,
          self.current_user.username)
        session[:gliffy] = Gliffy::Handle.new($gliffy_root,$gliffy_edit_root,cred)
    end
</pre>
<p>
Now you can use the gliffy handle in a controller or a view. Perhaps
you&#8217;d make an action to create a new document and send the user to
edit it:
</p>
<pre>
    def create
      new_doc = session[:gliffy].document_create(params[:name])
      redirect_to(session[:gliffy].document_edit_link(new_doc.document_id,
                  {:returnURL =&gt; url_for(:controller =&gt; 'return_from_gliffy'),
                   :returnButtonText =&gt; 'Back to My Awesome Blog'}))
    end
</pre>
<p>
It is recommended that you do not expose the <a
href="../../../classes/Gliffy.html">Gliffy</a> URLs directly in your views;
since each URL can be called one time only and they <b>must</b> be called
in the order generated, if you were to have, for example, a page with links
to images of your <a href="../../../classes/Gliffy.html">Gliffy</a>
diagrams, the browser may not request those links in the order that you
need.
</p>
<p>
Instead, create a route like so:
</p>
<pre>
    map.resources :diagrams, :only =&gt; [:index,:new,:destroy,:edit,:show]
</pre>
<p>
And implement all <a href="../../../classes/Gliffy.html">Gliffy</a> access
in your controller methods
</p>
<pre>
    # diagrams_controller.rb
    class DiagramsController &lt; ApplicationController

      Mime::Type.register 'image/jpeg', :jpg, [], [&quot;jpeg&quot;]
      Mime::Type.register 'image/png', :png, [], [&quot;png&quot;]
      Mime::Type.register 'image/svg+xml', :svg, [], [&quot;svg&quot;]

      def index
        @diagrams = self.gliffy_handle.folder_documents(APP_CONFIG['gliffy_folder']).sort{|a,b| a.name &lt;=&gt; b.name}
      end

      def show
        size = params[:size] || :L
        respond_to do |format|
          format.jpg { send_data session[:gliffy].document_get(params[:id],:jpeg,size), :type =&gt; &quot;image/jpeg&quot;, :disposition =&gt; 'inline' }
          format.png { send_data session[:gliffy].document_get(params[:id],:png,size), :type =&gt; &quot;image/png&quot;, :disposition =&gt; 'inline' }
          format.svg { send_data session[:gliffy].document_get(params[:id],:svg,size), :type =&gt; &quot;image/svg+xml&quot;, :filename =&gt; params[:id] + &quot;.svg&quot; }
          format.xml { send_data session[:gliffy].document_get(params[:id],:xml,size), :type =&gt; &quot;text/xml&quot;, :filename =&gt; params[:id] + &quot;.xml&quot; }
        end
      end

    # index.html.erb
    &lt;ul&gt;
      &lt;% @diagrams.each do |diagram| %&gt;
        &lt;li&gt;&lt;img src=&quot;&lt;%= diagram_path(diagram.document_id) %&gt;&quot; /&gt;&lt;/li&gt;
      &lt;% end %&gt;
    &lt;/ul&gt;
</pre>
<p>
This way, your application has links to your controller and the requests to
<a href="../../../classes/Gliffy.html">Gliffy</a> are constructed as the
browser makes requests to your application.
</p>
<h2>Digging Deeper</h2>
<p>
If you wish to bypass the high-level API, you can interact with <a
href="../../../classes/Gliffy.html">Gliffy</a> directly via the <a
href="../../../classes/Gliffy/Request.html">Gliffy::Request</a> class,
which allows you to make arbitrary requests against the <a
href="../../../classes/Gliffy.html">Gliffy</a> API, but takes care of
signing your URLs and all OAuth things that need to be done:
</p>
<pre>
    # Create a Credentials object as normal
    request = Gliffy::Request.new('www.gliffy.com/api/v1',credentials)
    # The method name maps directly to Gliffy's &quot;action&quot; parameters
    response = request.delete('accounts/$account_id/documents/12345')
</pre>
<p>
You can manipulate the response directly, or attempt to parse it using the
<a href="../../../classes/Gliffy/Response.html">Gliffy::Response</a>
object:
</p>
<pre>
    model = Response.from_http_response(response)
</pre>
<h1>Command Line Client</h1>
<p>
This also comes with a command line client that can serve as an example of
using the API. The command-line client is quite usable in its own right:
</p>
<pre>
    gliffy help
</pre>
<p>
This will list all the commands you can give to the <tt>gliffy</tt>
command. You can&#8217;t do <b>everything</b> with the command line that
you can with the full API, but you can do quite a bit
</p>
<pre>
    # set up your account
    &gt; gliffy config

    # List all documents in your account
    &gt; gliffy ls

    # Create a new document
    &gt; gliffy new &quot;My New Document&quot;
    Created document 123456 - My New Document

    # Edit it
    &gt; gliffy edit 123456

    # Make a new folder
    &gt; gliffy mkdir awesome

    # Move our new document there
    &gt; gliffy mv 123456 awesome

    # Get it as a PNG
    &gt; gliffy get -t png 123456
    Wrote 123456_L.png

    # Get help on a command
    &gt; bin/gliffy help get
    view [options]
        View a diagram as an image, or download it

    Options:
        -p, --publicurl                                - Get the Public URL only (if
                                                         possibe)
        -s, --size=L, M, S, T                          - Size (default: L)
        -t, --type=jpeg, png, svg, xml                 - File Type (default: jpeg)
        -u, --url                                      - Get the URL only
        -v, --version=version number (omit for latest) - Version
</pre>
<p>
:include:gliffy.rdoc
</p>
<h1>Design</h1>
<h2>Domain Objects</h2>
<p>
Instead of creating explicit objects for each domain object in <a
href="../../../classes/Gliffy.html">Gliffy</a>, we always return a Response
object, that uses method_missing to implement accessors for data returned
from <a href="../../../classes/Gliffy.html">Gliffy</a>. These implicit
accessors should return typed values and are named accordingly:
</p>
<ul>
<li>If the name in the <a
href="http://www.gliffy.com/developer/apidocs/xsddoc/">XSD</a> has dashes,
underscores are used here

</li>
<li>If the item is a boolean, its boolean value is available with a
&#8220;?&#8221; at the end

</li>
<li>The id field is available as type_id, e.g. document_id

</li>
<li>Date fields are converted to Time objects

</li>
<li>Any field in the response that was not known about in this code will be
available as a String, based on the above rules

</li>
</ul>
<p>
So, if you requested document meta data, you would have the following
accessors available:
</p>
<ul>
<li>document.document_id

</li>
<li>document.is_private?

</li>
<li>document.is_public?

</li>
<li>document.num_versions

</li>
<li>document.mod_date # returns a Time

</li>
<li>document.create_date # returns a Time

</li>
<li>document.published_date # returns a Time

</li>
<li>document.owner # Returns a Response that responds to user accessors

</li>
<li>document.versions # Returns an array of Response objects that act like
versions

</li>
</ul>
<h2>HTTP Layer</h2>
<p>
Request implements the HTTP layer, and is based on HTTParty. Since all <a
href="../../../classes/Gliffy.html">Gliffy</a> URLs have an
&#8220;action&#8221; HTTP param in them, this action is the method name,
followed by the URL on which to perform that action (this is not a REST
action, but specific to <a href="../../../classes/Gliffy.html">Gliffy</a>).
You can optionally include other HTTP params, however those needed for
authentication and signing are taken care of. Request will examine the
Credential object used to create the Request object, sign the request, make
the request and return the result. It will look at the result only enough
to determine if it&#8217;s an error, or a failure. See the RubyDoc for more
on how this works.
</p>
<h1>Development</h1>
<h2>Gems</h2>
<p>
You will need:
</p>
<pre>
 * sdoc 0.2.16 or better
 * httparty 0.4.2 or better
 * ruby-hmac 0.3.2 or better
 * gli 0.1.6 or better
</pre>
<p>
All of these save for hanna are installed if you installed the gem.
</p>
<h2>Unit Tests</h2>
<pre>
    rake test
</pre>
<p>
This will run unit tests and also create <tt>junit_output.xml</tt> as a
side-effect (via some monkeypatching of Ruby&#8217;s unit test code); this
should be a standard JUnit test result file you could use for integration
into your CI server.
</p>
<p>
Sometimes the test that two nonces shouldn&#8217;t be the same fails. This
occurs because they are generated in pretty much the same instant AND when
the random number generator generates the same number twice in a row.
Usually if you run tests again, things pass. This will be <b>very</b>
unlikely to happen in a production environment.
</p>
<h2>Integration Tests</h2>
<pre>
    rake inttest
</pre>
<p>
This code is capable of running integration tests against Gliffy&#8217;s
integration test servers. If you would like to run these tests, you must
contact <a href="../../../classes/Gliffy.html">Gliffy</a> for the
information needed. You could technically run integration tests against
your own <a href="../../../classes/Gliffy.html">Gliffy</a> account on their
production server, but this may delete or change your account&#8217;s data
and is not recommended. Once you have the information from <a
href="../../../classes/Gliffy.html">Gliffy</a>, create the file
`test/it_cred.rb` as follows:
</p>
<pre>
    $account_id = # integration tests account id
    $username = # integration tests admin user name
    $oauth_consumer_key = # integration test account consumer key
    $oauth_consumer_secret = # integration test account consumer secret
    $api_root = # integration test server API endpoint
    $http_auth_username = # integration test server HTTP Auth username
    $http_auth_password = # integration test server HTTP Auth password
</pre>
<h2>Functional Tests</h2>
<pre>
    rake functest
</pre>
<p>
The functional tests perform actual workflows against a <a
href="../../../classes/Gliffy.html">Gliffy</a> server and, as such, are
more fragile. If something is wrong in your environment (or with <a
href="../../../classes/Gliffy.html">Gliffy</a>), you could leave the test
account in a weird state. As such, you should create a new account using a
test-only API call. This can be done via
</p>
<pre>
    rake setup_account
</pre>
<p>
This requires that it_cred.rb is set up and will then run
test/setup_account.rb. This will create the file functest_cred.rb with the
necessary information to access the newly created account. The accounts
seem to get reset every day, so you will not be able to reliably automate
this. That being said, the only way to get 100% coverage is to run these
tests.
</p>
<p>
Each functional test assumes the following:
</p>
<ul>
<li>The account name is &#8216;Ruby Client Test Account&#8217;

</li>
<li>The account id is 1000001

</li>
<li>The only user is testuser@gliffy.com

</li>
<li>There are no documents/diagrams

</li>
<li>The only folder is ROOT

</li>
</ul>
<p>
Each test will put data into <a
href="../../../classes/Gliffy.html">Gliffy</a>, query it, and remove it,
thus leaving the account in the same state.
</p>
<p>
To fully test the edit launch link, run
</p>
<pre>
    rake TEST_LINK=true functest
</pre>
<p>
This will print out the launch link and pause the testing. Copy/Paste this
into your browser to make sure it works and then come back to the console
and hit return. Do not do this for automated builds.
</p>

    </div>
    

    

    
    

    
    

    

    

    
    <div class="sectiontitle">Classes and Modules</div>
    <ul>
        
        <li><span class="type">MODULE</span> <a href="../../../classes/Gliffy.html">Gliffy</a></li>
        
    </ul>
    

    

    

    
</div>
    </div>
  </body>
</html>